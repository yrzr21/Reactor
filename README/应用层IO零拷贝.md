
## 概述
- **目标**：报文抵达用户缓冲区后，不再进行多余的拷贝，而直接传递给业务层
- 暂不考虑 DPDK、mmap 等真正零拷贝方案...等后续技术精进了再说
- 报文的3次拷贝：网卡到内核缓冲区(可DMA)、内核缓冲区到应用缓冲区(可mmap)、用户缓冲区到业务层(本文目标)

---
## 报文问题
### 接收
#### 零拷贝
- 用一个由**指针+大小**构成的类指向接收缓冲区中的数据传递给业务层
- 采用**一次性、固定大小的缓冲区**，可迅速进行分配、释放、重用

#### 报文超过缓冲区大小
- 这将可能导致需要**多次系统调用**读取报文，并且需要拼接报文交给业务层，增加**处理复杂性**
- 可约定**单个连接的最大报文大小**，若需要传递更大的报文需要额外建立连接
#### 报文不完整
- **延迟**交给业务层，使用指针追踪上一个不完整报文开头在内存池中的位置
#### 报文超过缓冲区边界
- 如果业务层**不及时处理**应用层缓冲区，即便约定了最大报文大小，仍有可能超出缓冲区边界
- 为缓冲区**预留最大报文大小的空间**，如果容量不足这个值则立刻更换缓冲区
	- 可能会产生一定的内部碎片
	- 但由于零拷贝中提到的好处，这种碎片程度是可以容忍的
- 如果最后一个报文不完整、且超过预留阈值，若：
	1. 报文头都不完整，或者报文未接收部分够小，直接拷贝到新缓冲区，从而避免下次read允许读取的值过小
	2. 未接收部分够大，那还是下次读完整了再换池子吧
### 发送
- 基于 `writev` 一次发送多个不连续内存
#### 转移对象所有权
- 业务层传递给底层的对象内存来源较复杂，为了避免拷贝需要转移所有权
- 传递的一般为封装好的对象，直接**智能指针管理+移动**就好
#### iov 没发完
- 使用一个类统一管理每一个**发送单元**，包含头部+报文体，用于记录已发送的字节数、管理内部对象生命周期
- 在即将发送时，**根据发送单元构造 iov**，每次发送完了更新发送单元的状态
	- 有少量开销
- 另一种实现方式是，业务层传递给底层的数据直接构造iov，然后发送，不过这样管理极其困难，需要非常多的复杂逻辑判断，还是封装一下比较好
	- 比如，哪几个iov是一个发送单元，头在哪里，某个iov发送了一半怎么处理，怎么管理消息生命周期



---
## 内存池相关
### 基础思路
#### 动态内存申请优化
- 避免多次进行系统调用申请堆内存，使用 `std::pmr` 自行管理大部分内存
- 提前申请几乎全部所需内存，需要时进行分配
#### 减少锁竞争
- **线程私有**内存池，基于 `thread_local`+全局服务类
- 仅在线程私有池内存不够时向上游同步内存池进行申请
#### 提高复用率
- 线程私有内存池可能会**闲置**大量内存，需要回收释放给上游内存池
- 采取**引用计数/字节计数**的方式，在合适的时机可选择释放内存
### 实际问题
#### 申请的内存大小未知/已知
- 大小已知：
	1. 采用**块大小固定**的池就能很好解决
	2. 允许向上游申请新内存
- 大小未知：
	1. 提供内存池的**池指针**进行手动管理
	2. **块大小无需固定**，按段连续分配即可
	3. **池大小固定**，内存不够了再申请一个新池
	4. 需要一个类管理这些池的申请、更换、释放

- 在此基础上，可达成碎片程度可控，可快速进行分配、释放、重用的目的
#### 同对象多次/单次申请
- 对于大小已知的情形，std::pmr 的多次申请然后释放并不会有什么问题，其内部已经维护了块链表
- 对于大小未知的对象，可能需要手动实现类似的机制，来实现内存的释放
	- 但由于此处的未知大小的对象主要针对报文消息，它只需要单次申请内存
	- 报文消息需要足够快速的处理，上述机制可能会拖慢这种过程
	- 那么可以放弃这种机制，只需要让对象在释放时减小上游底层池的引用计数即可
#### 字节计数/引用计数
- **字节计数**：针对**多次申请**的对象，此类对象不可能在每次申请时都添加引用计数，又不可能添加一个表注册对象，所以还是用字节计数吧
- **引用计数**：针对单次申请的对象，只用一个引用计数即可与对象生命周期绑定，但字节计数也行
#### 内存池回收时机
- 计数为0，且要求回收时，或者析构时
### 并发问题
- 虽然池是线程私有的，但是对象还是可能被其他线程访问的，这意味着对象的申请、释放仍有并发问题
	- 对于仅申请一次的对象，只有释放有并发问题
	- 对于多次申请的对象，均有并发问题
#### 部分无锁优化
- 希望尽可能地减小内存池开销，虽说此处的竞争很少，但锁带来的开销仍然不小。且可以预见的，内存分配是非常**常见**的操作
- 综上，使用**原子变量**进行无锁优化，这需要考虑内存序
- 目前只实现了仅在单线程内部申请一次、多线程释放的无锁内存池，**真正的无锁内存池尚未实现**
#### 内存序
- x86平台内存序较强，但考虑到可移植性，其余平台例如arm、risc-v 内存序较弱，此处还是考虑一下
- 多个原子变量虽然可以保证自身的原子性，但不保证内存序
- 存在依赖的不用考虑内存序，因为肯定不会乱序

- 目前的场景：
	1. 在设置禁止继续分配内存前，后续释放池的操作应禁止提前，否则其余线程可能看到未禁止分配内存、且池已释放的场景
	2. 应禁止多个线程重复释放池，否则可能会释放空池，此处的释放不一定是幂等的，因为我们用了引用计数（改成字节计数可能好点）

### 全局服务点
- 将这些 buffer 注入到现在的体系中可谓非常困难，有的地方仅仅只是使用一下就要增加成员、设置函数、传递参数、处理各种逻辑，复杂性剧增
- 又考虑到现在的线程私有池，**可以设置一个全局服务点**，并在提供服务的函数中使用 `staic+thread_local` 的方式为一个线程中的所有内存申请提供服务
- 但耦合的比较紧密的，比如发送接收缓冲区，可以设置为成员










